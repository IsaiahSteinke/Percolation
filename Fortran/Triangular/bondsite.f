C     ==================================================================
C     Program: bondsite.f
C     Author: Isaiah Steinke
C
C     Runs a combination site-bond problem for a triangular lattice.
C     The user must specify the fraction of sites and bonds to fill via
C     variables ps and pb.  The code will first occupy the specified
C     fraction of bonds (all of these bonds are occupied clusters of
C     size 1).  Then, the sites with be occupied with the cluster sizes
C     appropriately modified after each site is occupied.  The code
C     utilizes three arrays:
C        - the site array, s, which lists the cluster the site
C          belongs to
C        - the bond array, b, which lists all the bonds and which
C          cluster the bond belongs to (bonds are denoted by the sites
C          they connect in the first two columns of the array)
C        - the cluster array, c, which lists the cluster size.
C     Note that there is no need for an 'index' for the site/cluster
C     arrays since the row number is essentially the number of the site
C     or cluster.  The order the sites and bonds are occupied is
C     generated by randomly swapping the order of the sites or bonds
C     in the two arrays, sorder and border.
C
C     Output from code:
C        - bssite.txt: lists the site/cluster number, the contents of
C          the site array, and the contents of the cluster array
C        - bsbond.txt: lists the contents of the bond array
C        - bsdebug.txt: essentially a copy of any messages that appear
C          on screen during execution for debugging.
C
C     Last Revision: November 18, 2010
C     ==================================================================

      program bondsite
      
      implicit none
      integer m, n, t, cln, pbc, scn, bcn, rc, nb
      integer sseed, bseed, lcn, lcs, clsum
      integer maxcn, maxcs, topfill, botfill, perccln, perccls
      integer i, j, k, l, temp, tsites, tbonds, rlc
      integer s(1000000), sorder(1000000), c(1000000), nn(10)
      integer b(3000000,3), border(3000000,2), btemp(2), nnb(12,4)
      real rand
      double precision ps, pb, f
      external nearestn
      common m, n, t, pbc, nn, scn

      open(unit=10, file='bssite.txt')
      open(unit=11, file='bsbond.txt')
      open(unit=12, file='bsdebug.txt')

C     dimensions of lattice m x n

         m = 10                   !width
         n = 10                   !height
         t = m*n                  !total number of lattice sites
         
C     fraction of lattice sites and bonds to fill (user specified)

         ps = 0.50d+00            !fraction of sites to fill
         pb = 0.50d+00            !fraction of bonds to fill

C     random number seeds for generating the order of site and bond
C     occupation (must be integers)

         sseed = 143285
         bseed = 43716

C     toggle for periodic boundary conditions on the left/right sides
C     note that the pbc flag only makes sense for m even with the
C     current lattice geometry (triangular)

         pbc = 0                  !set to 1 if using p.b.c.

C     lattice-specific geometry constants (need to be changed if the
C     lattice is changed)

         scn = 6                  !site coordination number
         bcn = 10                 !bond coordination number

C     calculate the overall total number of bonds possible (depends on
C     lattice geometry

         if (pbc.eq.1) then
            nb = m*(3*n-2)
         else
            nb = (3*m*n)-(2*m)-(2*n)+1
         end if

C     initialize arrays to zero for all elements (if the declared array
C     sizes change, you will need to modify the do loops here - the
C     bond array should have 3x the number of rows as the site array to
C     account for the geometry)

         do i = 1,1000000
            s(i) = 0              !site array
            c(i) = 0              !cluster array
         end do

         do i = 1,10
            nn(i) = 0             !nearest neighbor array
         end do
         
         do i = 1,3000000
            do j = 1,3
               b(i,j)=0           !bond array
            end do
         end do

C     ------------------------------------------------------------------
C     generate the array that lists the order of site occupation
C     ------------------------------------------------------------------

         call srand(sseed)        !seeds the random number generator

C        initialize sorder array

         do i = 1,t
            sorder(i) = i
         end do

C        permute sites randomly in the sorder array

         do i = 1,t
            j = i + (t-i+1)*rand(0)
            temp = sorder(i)
            sorder(i) = sorder(j)
            sorder(j) = temp
         end do
C     ------------------------------------------------------------------

C     ------------------------------------------------------------------
C     generate the list of bonds in the bond array and set the
C     occupation equal to zero; initialize the bond order array
C     ------------------------------------------------------------------

         rc = 1                   !row number (counter)

         do i = 1,(t-1)
            call nearestn(i)
            do j = 1, scn
               if (nn(j).gt.i) then
                  b(rc,1) = i
                  b(rc,2) = nn(j)
                  b(rc,3) = 0
                  border(rc,1) = i
                  border(rc,2) = nn(j)
               else
                  goto 210
               end if
               rc = rc + 1
210            continue
            end do
         end do
C     ------------------------------------------------------------------

C     ------------------------------------------------------------------
C     randomize the order in which the bonds are filled in the bond
C     order array
C     ------------------------------------------------------------------

         call srand(bseed)        !seeds the random number generator

C     permute bonds randomly in the bond order array

         do i = 1,nb
            j = i + (nb-i+1)*rand(0)
            btemp(1) = border(i,1)
            btemp(2) = border(i,2)
            border(i,1) = border(j,1)
            border(i,2) = border(j,2)
            border(j,1) = btemp(1)
            border(j,2) = btemp(2)
         end do
C     ------------------------------------------------------------------

C     ==================================================================
C     occupy the specified fraction of bonds
C     ==================================================================

         write(6,*) "Specified fraction of bonds to fill:", pb
         write(12,*) "Specified fraction of bonds to fill:", pb

         tbonds = pb*nb           !number of bonds to occupy
         cln = 1                  !lowest unused cluster number
         
         do i = 1,tbonds
            write(6,*) "Bond occupied:", border(i,1), border(i,2)
            write(12,*) "Bond occupied:", border(i,1), border(i,2)
            do j=1,nb             !this loop occupies the bond
               if (b(j,1).eq.border(i,1)) then
                  if (b(j,2).eq.border(i,2)) then
                     b(j,3) = cln
                  end if
               end if
            end do
            c(cln) = 1            !all bonds occupy clusters of size 1
            cln = cln+1           !increment the lowest unused cluster number
         end do

         f = real(tbonds)/real(nb)

         write(6,*) "Actual fraction of bonds filled:", f
         write(12,*) "Actual fraction of bonds filled:", f
         write(6,*) "===================="
         write(12,*) "===================="
C     ==================================================================
         
C     set the maximum cluster size to 1 and arbitrarily set the largest
C     cluster number to be 1

         maxcn = 1
         maxcs = 1

C     ==================================================================
C     occupy sites and update cluster numbers/sizes appropriately
C     ==================================================================

         write(6,*) "Specified fraction of sites to fill:", ps
         write(12,*) "Specified fraction of sites to fill:", ps

         tsites = ps*t            !number of sites to occupy
         lcn = 0                  !temp variable for largest cluster number
         lcs = 0                  !temp variable for largest cluster size

         do i = 1,tsites
            write(6,*) "Site occupied:", sorder(i)
            write(12,*) "Site occupied:", sorder(i)

C     initialize the nearest neighbor bond matrix to zero

            do j = 1,4
               do k = 1,12
                  nnb(k,j) = 0
               end do
            end do
            
C     populate the nearest neighbor bond matrix with useful info

            rc = 1                !reset row number/counter

            call nearestn(sorder(i))
            do j = 1,scn
               if (nn(j).ne.0) then
                  if(nn(j).gt.sorder(i)) then
                     nnb(rc,1) = sorder(i)
                     nnb(rc,2) = nn(j)
                  else
                     nnb(rc,1) = nn(j)
                     nnb(rc,2) = sorder(i)
                  end if
                  rc = rc + 1
               end if
            end do

            do j = 1,nb
               do k = 1,scn
                  if(b(j,1).eq.nnb(k,1)) then
                     if(b(j,2).eq.nnb(k,2)) then
                        nnb(k,3) = b(j,3)        !cluster number
                        nnb(k,4) = c(b(j,3))     !cluster size
                     end if
                  end if
               end do
            end do
            
C     find out which nearest neighbor bond is attached to the largest
C     cluster and get the largest cluster number and size associated
C     with that nearest neighbor bond

            lcn = nnb(1,3)        !current largest cluster number (arbitrarily set)
            lcs = nnb(1,4)        !current largest cluster size (arbitrarily set)
            rlc = 1               !row of data in the n.n. bond matrix containing the largest cluster

            do k = 2,scn
               if (nnb(k,1).ne.0) then           !no valid n.n. bond if =0
                  if (nnb(k,3).ne.0) then        !n.n. bond unoccupied if =0
                     if (nnb(k,4).gt.lcs) then
                        lcn = nnb(k,3)
                        lcs = nnb(k,4)           !or lcs = c(nnb(k,3))
                        rlc = k
                     end if
                  end if
               end if
            end do


C     Case 1: no n.n. bonds are occupied; site becomes its own cluster

            if (lcs.eq.0) then
               s(sorder(i)) = cln
               c(cln) = 1
               write(6,*) "*no neighboring bonds are occupied*"
               write(6,*) "site assigned to cluster number", cln
               write(12,*) "*no neighboring bonds are occupied*"
               write(12,*) "site assigned to cluster number", cln
               cln = cln+1
               goto 310
            end if

C     Case 2: one or more nearest neighbors occupied (i.e. lcs > 0)

            clsum = lcs                                    !temp variable for summing cluster size
            write(6,*) "*one or more n.n. bonds occupied*"
            write(12,*) "*one or more n.n. bonds occupied*"

            do k = 1,scn
               if (nnb(k,1).ne.0) then                     !no valid n.n. if =0
                  if (nnb(k,3).ne.0) then                  !n.n. unoccupied if =0
                     if (nnb(k,3).ne.lcn) then             !filters out n.n. already belonging to the largest cluster
                        if (k.ne.1) then                   !this should check to make sure the same cluster number is not "counted" more than once
                           do l = 1,(k-1)
                              if (nnb(l,3).eq.nnb(k,3)) then
                                 goto 320
                              end if
                           end do
                        end if
                        clsum = clsum + nnb(k,4)           !adds cluster size to largest cluster
                write(6,*) "adding", nnb(k,4), " to largest cluster"
                write(6,*) "largest cluster is now", clsum
                write(12,*) "adding", nnb(k,4), " to largest cluster"
                write(12,*) "largest cluster is now", clsum
                        do j = 1,nb
                           if (b(j,3).eq.nnb(k,3)) then    !this loop re-numbers all the bonds belonging to the smaller cluster with the largest cluster number
                              b(j,3) = lcn
                           end if
                        end do
                        do j = 1,t                         !this loop re-numbers all the sites belonging to the smaller cluster with the largest cluster number
                           if (s(j).eq.nnb(k,3)) then
                              s(j) = lcn
                           end if
                        end do
320                     c(nnb(k,3)) = 0                    !smaller cluster now contains zero sites
                     end if
                  end if
               end if
            end do

C     add occupied site to the largest cluster

            s(sorder(i)) = lcn
            clsum = clsum+1
            c(lcn) = clsum
            write(6,*) "site assigned to cluster number", lcn
            write(6,*) "size of cluster number", lcn, " is now", c(lcn)
            write(12,*) "site assigned to cluster number", lcn
            write(12,*) "size of cluster number", lcn, " is now", c(lcn)

C     update the largest overall cluster number and size variables
310         if (c(lcn).gt.maxcs) then
               maxcs = c(lcn)
               maxcn = lcn
            end if
            write(6,*) "--------------------"
            write(12,*) "--------------------"
         end do

         f = real(tsites)/real(t)

         write(6,*) "Actual fraction of sites filled:", f
         write(12,*) "Actual fraction of sites filled:", f
C     ==================================================================

         write(6,*)
         write(6,*) "******************************"
         write(12,*)
         write(12,*) "******************************"

C     output the largest cluster number and size

         write(6,*) "largest overall cluster number:", maxcn
         write(6,*) "largest overall cluster size:", maxcs
         write(12,*) "largest overall cluster number:", maxcn
         write(12,*) "largest overall cluster size:", maxcs
         
C     ==================================================================
C     check for percolation, i.e. presence of lattice spanning cluster
C     ==================================================================
         do i = 1,(cln-1)
            botfill = 0           !used for checking if the bottom row contains a site
            topfill = 0           !used for checking if the top row contains a site
            if (c(i).ge.(2*n-1)) then   !only clusters with size 2n-1 could span the lattice
               write(6,*) "testing cluster", i   !useful debugging message
               write(12,*) "testing cluster", i
               do j = 1,m
                  if (s(j).eq.i) then
                     botfill = 1
                     goto 410
                  end if
               end do
               write(6,*) "source end not connected"
               write(12,*) "source end not connected"
               goto 430
410            do j = (t-m+1),t
                  if (s(j).eq.i) then
                     topfill = 1
                     goto 420
                  end if
               end do
               write(6,*) "drain end not connected"
               write(12,*) "drain end not connected"
420            if ((topfill+botfill).eq.2) then
                  write(6,*) "infinite cluster present"
                  write(12,*) "infinite cluster present"
                  perccln = i     !infinite cluster number
                  perccls = c(i)  !infinite cluster size
                  write(6,*) "infinite cluster number:", perccln
                  write(12,*) "infinite cluster number:", perccln
                  write(6,*) "infinite cluster size:", perccls
                  write(12,*) "infinite cluster size:", perccls
                  goto 440
               end if
430         end if
         end do

         write(6,*) "no infinite cluster present"
         write(12,*) "no infinite cluster present"
C     ==================================================================

440      write(6,*) "******************************"
         write(12,*) "******************************"

C     output the contents of the site, bond, and cluster arrays

         do i=1,nb                !need to go to nb instead of t in case cluster numbers get large
            write(10,111) i, s(i), c(i)
         end do
         
         do i=1,nb
            write(11,111) b(i,1), b(i,2), b(i,3)
         end do

111      format(i10,",",i10,",",i10)

         stop
      end

C     ==================================================================
C     nearest neighbor subroutine that should populate the the nearest
C     neighbor array with the site numbers of the nearest neighbors for
C     a particular site - needs to be changed for different lattice
C     geometry
C     ==================================================================

      subroutine nearestn(rn)

      implicit none
      integer rn, m, n, t, pbc, scn
      integer z
      integer nn(10)
      common m, n, t, pbc, nn, scn

C     zero out the nearest neighbor array

         do z = 1,scn
            nn(z) = 0
         end do

C     check: lower-left corner site
            if (rn.eq.1) then
               nn(1) = rn+1
               nn(2) = rn+m
               nn(3) = rn+(m+1)
               if (pbc.eq.1) then
                  nn(4) = rn+(m-1)
                  nn(5) = rn+(2*m-1)
               end if
               goto 510
            end if

C     check: lower-right corner site
            if (rn.eq.m) then
               nn(1) = rn-1
               nn(2) = rn+m
               if (mod(m,2).eq.1) then !check for odd m
                  nn(3) = rn+(m-1)
                  goto 510
               end if
               if (pbc.eq.1) then
                  nn(3) = 1
               end if
               goto 510
            end if

C     check: upper-left corner site
            if (rn.eq.(t-(m-1))) then
               nn(1) = rn-m
               nn(2) = rn+1
               if (pbc.eq.1) then
                  nn(3) = t
               end if
               goto 510
            end if

C     check: upper-right corner site
            if (rn.eq.t) then
               if (mod(m,2).eq.1) then !check for odd m
                  nn(1) = rn-m
                  nn(2) = rn-1
                  goto 510
               end if
               nn(1) = rn-(m+1)
               nn(2) = rn-m
               nn(3) = rn-1
               if (pbc.eq.1) then
                  nn(4) = rn-(2*m-1)
                  nn(5) = rn-(m-1)
               end if
               goto 510
            end if

C     check: bottom row site (i.e. source edge)
            if (rn.lt.m) then
               if (mod(rn,2).eq.0) then
                  nn(1) = rn-1
                  nn(2) = rn+1
                  nn(3) = rn+m
               else
                  nn(1) = rn-1
                  nn(2) = rn+1
                  nn(3) = rn+(m-1)
                  nn(4) = rn+m
                  nn(5) = rn+(m+1)
               end if
               goto 510
            end if

C     check: top row site (i.e. drain edge)
            if (rn.gt.(t-m)) then
               if (mod(rn,2).eq.0) then
                  nn(1) = rn-(m+1)
                  nn(2) = rn-m
                  nn(3) = rn-(m-1)
                  nn(4) = rn-1
                  nn(5) = rn+1
               else
                  nn(1) = rn-m
                  nn(2) = rn-1
                  nn(3) = rn+1
               end if
               goto 510
            end if

C     check: left edge site
            if (mod((rn-1),m).eq.0) then
               nn(1) = rn-m
               nn(2) = rn+1
               nn(3) = rn+m
               nn(4) = rn+(m+1)
               if (pbc.eq.1) then
                  nn(5) = rn+(m-1)
                  nn(6) = rn+(2*m-1)
               end if
               goto 510
            end if

C     check: right edge site
            if (mod(rn,m).eq.0) then
               if (mod(m,2).eq.1) then !check for odd m
                  nn(1) = rn-m
                  nn(2) = rn-1
                  nn(3) = rn+(m-1)
                  nn(4) = rn+m
                  goto 510
               end if
               nn(1) = rn-(m+1)
               nn(2) = rn-m
               nn(3) = rn-1
               nn(4) = rn+m
               if (pbc.eq.1) then
                  nn(5) = rn-(2*m-1)
                  nn(6) = rn-(m-1)
               end if
               goto 510
            end if

C     general interior site
            if (mod(m,2).eq.1) then  !check for odd m
               if(mod((rn/m),2).eq.0) then  !even row
                  if (mod(rn,2).eq.0) then
                     nn(1) = rn-(m+1)
                     nn(2) = rn-m
                     nn(3) = rn-(m-1)
                     nn(4) = rn-1
                     nn(5) = rn+1
                     nn(6) = rn+m
                  else
                     nn(1) = rn-m
                     nn(2) = rn-1
                     nn(3) = rn+1
                     nn(4) = rn+(m-1)
                     nn(5) = rn+m
                     nn(6) = rn+(m+1)
                  end if
               else                         !odd row
                  if (mod(rn,2).eq.0) then
                     nn(1) = rn-m
                     nn(2) = rn-1
                     nn(3) = rn+1
                     nn(4) = rn+(m-1)
                     nn(5) = rn+m
                     nn(6) = rn+(m+1)
                  else
                     nn(1) = rn-(m+1)
                     nn(2) = rn-m
                     nn(3) = rn-(m-1)
                     nn(4) = rn-1
                     nn(5) = rn+1
                     nn(6) = rn+m
                  end if
               end if
            else
               if (mod(rn,2).eq.0) then
                  nn(1) = rn-(m+1)
                  nn(2) = rn-m
                  nn(3) = rn-(m-1)
                  nn(4) = rn-1
                  nn(5) = rn+1
                  nn(6) = rn+m
               else
                  nn(1) = rn-m
                  nn(2) = rn-1
                  nn(3) = rn+1
                  nn(4) = rn+(m-1)
                  nn(5) = rn+m
                  nn(6) = rn+(m+1)
               end if
            end if

510      end subroutine
C     ==================================================================
